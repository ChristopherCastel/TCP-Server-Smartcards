/*
 * engine.cpp
 *
 *  Created on: 22 Feb 2019
 *      Author: Castel Christopher
 */

// TODO Avoir un objet "strategy" pour chacune des commandes
// Avec peut-être un trucweight pour les conserver et facilement les appeler via le code de la requête ?

#define _WIN32_WINNT 0x501
#define WIN32_LEAN_AND_MEAN

#define DEFAULT_BUFLEN 512

#include <fstream>
#include <future>
#include <iostream>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <thread>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>

#include "nlohmann/json.hpp"
#include "plog/include/plog/Log.h"
#include "plog/include/plog/Appenders/ColorConsoleAppender.h"

#include "client_data.h"
#include "server_engine.h"
#include "../constants/request_code.h"
#include "../constants/response_packet.h"

using namespace responses;

namespace server {

ServerEngine::ServerEngine() { }

ResponsePacket ServerEngine::initServer(std::string path) {
	// json config file
		std::ifstream i(path);
		nlohmann::json j;
		i >> j;

		// setup logger
		std::string logfile_path = j["log_path"];
		std::string log_level = j["log_level"];
		static plog::ConsoleAppender<plog::TxtFormatter> consoleAppender;
		if (log_level.compare("debug") == 0) {
			plog::init(plog::debug, logfile_path.c_str()).addAppender(&consoleAppender);
		} else {
			plog::init(plog::info, logfile_path.c_str()).addAppender(&consoleAppender);
		}

		// launch engine
		LOG_INFO << "Server launched";
}

ResponsePacket ServerEngine::startListening() {
	LOG_INFO << "Start listening";
	WSADATA wsaData;
	int retval;

	struct addrinfo *result = NULL;
	struct addrinfo hints;

	// initializes Winsock
	retval = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (retval != 0) {
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "WSAStartup failed" };
		return response_packet;
	}

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the server address and port
	retval = getaddrinfo(ip.c_str(), port.c_str(), &hints, &result);
	if (retval != 0) {
		WSACleanup();
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Can't resolve server address and port" };
		return response_packet;
	}

	// Create a SOCKET for connecting to server
	listen_socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (listen_socket == INVALID_SOCKET) {
		freeaddrinfo(result);
		WSACleanup();
		LOG_DEBUG << "Socket creation failed with error:" << WSAGetLastError();
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Socket creation failed" };
		return response_packet;
	}

	// Setup the TCP listening socket
	retval = bind(listen_socket, result->ai_addr, (int) result->ai_addrlen);
	if (retval == SOCKET_ERROR) {
		freeaddrinfo(result);
		closesocket(listen_socket);
		WSACleanup();
		LOG_DEBUG << "Socket bind failed with error:" << WSAGetLastError();
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Bind failed" };
		return response_packet;
	}

	freeaddrinfo(result);

	retval = listen(listen_socket, SOMAXCONN);
	if (retval == SOCKET_ERROR) {
		closesocket(listen_socket);
		WSACleanup();
		LOG_DEBUG << "Socket listen failed with error:" << WSAGetLastError();
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Listen failed" };
		return response_packet;
	}

	std::thread thr(&ServerEngine::handleConnections, this, listen_socket);
	std::swap(thr, connection_thread);

	ResponsePacket response_packet;
	return response_packet;
}

ResponsePacket ServerEngine::handleConnections(SOCKET listen_socket) {
	while (!stop_flag.load()) {
		SOCKET client_socket = INVALID_SOCKET;

	    timeval timeout = {0, 0}; // select will return immediately
		fd_set fds;
		FD_ZERO(&fds);
		FD_SET(listen_socket, &fds);

		select(listen_socket, &fds, NULL, NULL, &timeout);

		if (FD_ISSET(listen_socket, &fds)) {
			client_socket = accept(listen_socket, NULL, NULL);
			if (client_socket == INVALID_SOCKET) {
				LOG_DEBUG << "Accept failed with error: " << WSAGetLastError();
				ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Connection with client failed" };
				return response_packet;
			}

			std::future<ResponsePacket> fut = std::async(std::launch::async, &ServerEngine::connectionHandshake, this, client_socket);
			// blocks until the timeout has elapsed or the result becomes available.
			if (fut.wait_for(std::chrono::milliseconds(default_timeout)) == std::future_status::timeout) {
				// connection has timed out
			} else {
				fut.get();
			}
		}
	}

	ResponsePacket response_packet;
	return response_packet;
}

ResponsePacket ServerEngine::connectionHandshake(SOCKET client_socket) {
	char recvbuf[DEFAULT_BUFLEN];
	setsockopt(client_socket, SOL_SOCKET, SO_RCVTIMEO, (char*) &default_timeout, sizeof(default_timeout));
	int retval = recv(client_socket, recvbuf, DEFAULT_BUFLEN, 0);
	if (retval == SOCKET_ERROR) {
		if (WSAGetLastError() != WSAETIMEDOUT) {
			ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Network error on receive" };
			return response_packet;
		} else {
			ResponsePacket response_packet = { .err_server_code = ERR_TIMEOUT, .err_server_description = "Connection time elapsed" };
			return response_packet;
		}
	}

	if (retval > 0) {
		recvbuf[retval] = '\0';
		ClientData* client = new ClientData(client_socket, ++next_client_id, recvbuf);
		clients.insert(std::make_pair(client->getId(), client));
		LOG_INFO << "Client connected: id = " << client->getId() << ", name = " << client->getName();
		ResponsePacket response_packet;
		return response_packet;
	} else {
		LOG_DEBUG << "Connection reset by peer";
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Network error no data received" };
		return response_packet;
	}
}

ResponsePacket ServerEngine::handleRequest(int id_client, RequestCode request, std::string data, DWORD timeout) {
	if (clients.find(id_client) == clients.end()) {
		LOG_DEBUG << "Request sent: " << requestCodeToString(request) << " - Client ID: " << id_client << " - Data: " << data;
		ResponsePacket response_packet = { .err_server_code = ERR_CLIENT_CLOSED, .err_server_description = "Client closed or not found" };
		return response_packet;
	}

	SOCKET client_socket = clients.at(id_client)->getSocket();

	nlohmann::json j;
	j["request"] = request;
	j["data"] = data;
	j["timeout"] = timeout;

	// sends async request to client
	std::future<ResponsePacket> fut = std::async(std::launch::async, &asyncRequest, this, client_socket, j.dump(), timeout);

	// blocks until the timeout has elapsed or the result becomes available.
	if (fut.wait_for(std::chrono::milliseconds(timeout)) == std::future_status::timeout) {
		// thread has timed out
		LOG_DEBUG << "Response time from client has elapsed";
		ResponsePacket response_packet = { .err_server_code = ERR_TIMEOUT, .err_server_description = "Request time elapsed" };
		return response_packet;
	}

	return fut.get();
}

ResponsePacket ServerEngine::asyncRequest(SOCKET client_socket, std::string to_send, DWORD timeout) {
	const char* to_send_char = to_send.c_str();
	LOG_INFO << "Data sent to client: " << to_send_char;
	int retval = send(client_socket, to_send_char, strlen(to_send_char), 0);
	if (retval == SOCKET_ERROR) {
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Network error on send request" };
		return response_packet;
	}

	// waits for response from client
	char recvbuf[DEFAULT_BUFLEN];
	setsockopt(client_socket, SOL_SOCKET, SO_RCVTIMEO, (char*) &timeout, sizeof(timeout));
	retval = recv(client_socket, recvbuf, DEFAULT_BUFLEN, 0);
	if (retval == SOCKET_ERROR) {
		if (WSAGetLastError() == WSAETIMEDOUT) {
			LOG_DEBUG << "Timeout error on receive  [socket " << client_socket << "]";
			ResponsePacket response_packet = { .err_server_code = ERR_TIMEOUT, .err_server_description = "Request time elapsed" };
			return response_packet;
		} else {
			LOG_DEBUG << "Network error on receive on [socket " << client_socket << "]";
			ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Network error on receive" };
			return response_packet;
		}
	}

	// processes client's response
	if (retval > 0) {
		recvbuf[retval] = '\0';
		LOG_INFO << "Data received: " << recvbuf << " - bytes received: " << retval;
		nlohmann::json response = nlohmann::json::parse(recvbuf); // parses response to json object
		ResponsePacket response_packet;
		return response_packet;
	} else {
		LOG_DEBUG << "Client is down on socket " << client_socket;
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Network error no data received" };
		return response_packet;
	}
}

ResponsePacket ServerEngine::listClients() {
	std::string output = std::to_string(clients.size());
	for (const auto &p : clients) {
		output += " " + std::to_string(p.first);
	}
	ResponsePacket response_packet = { .response = output };
	return response_packet;
}

ResponsePacket ServerEngine::stopAllClients() {
	stop_flag = true; // stop active threads
	connection_thread.join();

	for (const auto &p : clients) {
		stopClient(p.first);
		delete(p.second);
	}

	closesocket(listen_socket);
	WSACleanup();


	ResponsePacket response_packet;
	return response_packet;
}

ResponsePacket ServerEngine::stopClient(int id_client) {
	SOCKET client_socket = clients.at(id_client)->getSocket();

	ResponsePacket response_packet = handleRequest(id_client, DISCONNECT);
	if (response_packet.err_server_code  < 0) {
		return response_packet;
	}

	int retval = shutdown(client_socket, SD_SEND);
	if (retval == SOCKET_ERROR) {
		ResponsePacket response_packet = { .err_server_code = ERR_NETWORK, .err_server_description = "Client shutdown failed" };
		return response_packet;
	}
	closesocket(client_socket);

	return response_packet;
}

} /* namespace server */
